1. 문제를 못풀경우 기록하자.
  -. 어떤 알고리즘을 적용할려고 했는지
  -. 근거는 무엇인지
  -. 문제를 푸는 과정에서 내가 떠올린 알고리즘을 어떻게 코드로 만들려고 했는지?

2. 시험보듯이 시간을 재서 공부하라
  -. 긴장감과 시간배분을 학습해야한다.

3. 남의 답장지를 보고 해결했으면
  -. 요약노트를 작성하여 정리하자

4-1. 문제를 분석하면서 풀어라
  -. 전체 시간의 50%는 문제를 분석하는데 할애해야한다.
  -. 문제를 쪼개고 쪼개어 분석해야한다.
  -. 제약사항을 파악하고 테스트케이스를 추가해라
  -. 핵심키워드를 파악하여 문제를 빠르게 해석할줄 알아야 한다.

4-2. 분석 후 의사코드로 설계하기
  -. 세부구현이 아닌 동작으로 설계하라 (세부구현으로 들어가는순간 구현으로 되는것)
  -. 문제해결 순서로 작성하기.
  -. 의사코드에 대해서 충분히 테스트를 해라 (구현단계에서 테스트케이스 실패시 고쳐야하면 추가로 드는 비용이 너무 커서 의사코드설계시 충분히 테스트해야한다._

5. 시간복잡도
  -. 1차원 배열에서 값이 맨처음에 있으면 빠르게 검색하고, 맨뒤에 있거나 아예 없을 경우 실행시간이 느려진다.
  -. 시간복잡도를 측정하는 방법
    ->> 연산횟수와 관련이 있다. 알고리즘이 시작한 순간부터 결괏값이 나올 때 까지의 연산 횟수를 말하는것이다. (배열 1번을 찾을 경우 최선 연산은 1 맨마지막 배열인 8번쨰를 찾으면 최악연산 횟수 8이다.)
    ->> 특정 입력 크기에 한하여 연산횟수를 기준으로 시간 복잡도를 측정하면 안 된다. 입력 크기를 N으로 일반화하여 연산 횟수의 추이를 나타내야한다. 이런 방식으로 입력 크기에 따른 연산 횟수의 추이를 활용해서
        시간복잡도를 표현하는 방법을 점근적 표기법이라고 한다. 그리고 코딩테스트에서 모든 경우의 수에서 알고리즘이 문제를 처리하는 것을 고려해야 하므로 시간복잡도는 최악의 경우를 가정하여 이야기 한다.
  -. 최악의 경우에 대한 시간 복잡도를 표현하는 방법중 가장 많이 사용하는 점근적 표기법은 상한선을 활용하는 방법이다. 그리고 이 표기법을 빅오 표기법이라고 한다.
  -. 빅오표기법은 : 함수에서 최고차항을 남기고 차수를 지워 O(..)와 같이 표기한다. 
    ->> 3x2+5x : 0(x2)
    ->> 2x승 +10x5승 : 0(2x)
    ->> 지수함수 (2x승) > 다항함수 (3x2) > 로그함수 (logx)

6. 시간복잡도를 코딩테스트에 접목하기.
    -. 연산횟수는 1000~3000만 정도로 고려해서 시간복잡도를 생각하면 된다. (예르르 들면 제한시간이 1초인 문제는 연산 횟수가 3000만이 넘는 알고리즘은 사용하면 안된다.
    -. 각 시간복잡도에 따른 최대 연산 횟수는
      -: O(N!)  = 10 
      -: O(2n승)  =  20~25
      -: O(N3승)  =  200~300
      -: O(N2승)  =  3000~5000
      -: O(NlogN) =  100만 
      -: O(N)  =  1000~2000만
      -: O(logN) = 10억

      즉 시간복잡도가 O(N)인 1차원 배열에서 찾는다면 데이터의 개수가 10000만개 이하일 경우에만 사용이 가능하다.

7. 시간복잡도 계산해보기
      -. 별을 1, 2, 3, 4, 5 계속 찍히도록 하는 것은 O(n2승)
      -. 세균이 1시간 마다 1/2씩 줄어드는것은 O(logN)

8. 언어 자체에서 제공하는 데이터 타입정수형 (1,2,3,4) 부동소수형 (1.2, 2.5, 4.2)

9. 엡실론을 포함한 연산에 주의하라. 
  -. 부동소수형을 다르게 되면 파이썬은 이진법으로 소수형을 표현하기 떄문에 3.21523 와 같이 딱 맞아 떨어지게 데이터가 나오지 않을수 있다. 이것을 엡실론이라고 한다.

10. 컬렉션 데이터 타입 (리스트, 튜플, 딕셔너리, 셋, 문자열)
  -. 이 데이터는 변경할수 있는 객체(mutable object) 변경할수 없는 객체 (immutable object)가 있다.
    ->> mutable객체는 리스트, 딕셔너리, 셋이 있다.
    ->> immutable객체는 정수, 부동소수점, 문자열, 튜플이 있다.

11. 리스트 리스트는 시퀀스(순서)가 있는 자료형이다. 이런 특징으로는 인덱싱, 슬라이싱을 할수 있다.
  -. 인덱싱 :인덱스를 활용해서 특정 위치의 원소에 접근하는 것을 말한다. 
      my_list = [1,2,4]가 있을 경우 값의 추가와 삭제 변경은
      my_list.append(6)
      del my_list[2]
      my_list[2] = 3
    으로 할수가 있다.

12. 리스트 슬라이싱 
  -. 슬라이싱 : 시퀀스 자료형의 범위를 지정해서 값들을 복사하여 가져오는 방식
      my_list[a:b] a 이상부터 b 미만

13. 딕셔너리
  -. 딕셔너리는 파이썬에서 키와 값으로 쌍을 이루는 뮤터 자료형을 말한다.
      my_dict = {}
      my_dict["apple"] = 1
      my_dict["banana"] = 2
      my_dicy =>> {'appel' :1, 'banana' : 2}

  -. 딕셔너리 값 수정, 조회, 삭제, 생성
    생성 : my_dict = {"apple" : 1, "banana" : 2}
    조회 : my_dict["apple"]
    수정 : my_dict["apple"] = 5
    삭제 : del my_dict["apple"]

14. 튜플 (튜플은 immutable 이다.)
  -. 값의 초기화는 my_tuple = (1,2,3) 이며 인덱싱 슬라이싱은 되지만 수정,삭제는 안된다.

15. 문자열 (문자열은 immutable 이다.)
  -. 문자열은 "" 이나 '' 로 묶어서 사용한다.
  -. 문자열은 추가를 할시 새로운 객체로 추가된다
    ->> my_string = "he"
        my_string += "llo"
        my_string >> hello
  -. 문자열의 수정은 replace를 사용한다.
    ->> my_string = "hello"
        my_string.replace("l","")
        my_string >> heo        

16. 함수의 정의 
 def my_fucntion (param1, param2..., paramN):
    return result

  ->> 함수 호출
    ret = my_fucntion(5,10)

17. 람다식 (람다식은 익명의 함수로서 딱 1번만 사용하거나, 다른 함수의 인수로 사용될 목적으로 사용된다.)
  -. add = lambda x,y : x+y
    ->> ret = add(5,8) # 13
  -. 인수로 람다식 넘기는 방법
    ->> num = [1,2,3,4,5]
        squares = list(map(lambda x : x**2 , num))
        print(squares)  #[1,4,9,16,25]
      -->> map()함수는 2번쨰 인수로 넘어온 리스트에 1번쨰 인수로 받은 람다식을 적용하여 새로운 리스트를 반환한다.

18. 코딩테스트 코드 구현시 노하우
  1. 조기반환 (코드 실행 과정이 함수 끝까지 도달하기 전에 반환하는 기법이다. 이 방식은 코드의 가독성을 높여줄 뿐만 아니라 예외를 조금더 깔끔하게 하고 빠르게 처리 가능하다.)
    if totla > 100:
      return total * 0.9
    return total
    와 같이 조기에 함수 자체를 종료하고 이후에 예외에 대한 처리를 하지 않아도 된다.

  2. 보호구문 (본격적인 로직이 진행하기 전에 예외 처리 코드를 추가하는 기법)
    if number is None:
      return None
    if not isinstance(numbers, list):
      return None

  3. 합성함수 (2개 이상의 함수를 활용하여 함수를 추가로 만드는 기법)
    def add_three(x):
      return x+3

    def square(x):
      return x*x

    composed_function = lambda x : square(add_three(x))







































